diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index b6bb4e0ce0e3..af7c5e2f2b4f 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -3463,13 +3463,14 @@ static void sd_shutdown(struct device *dev)
 		return;
 
 	if (sdkp->WCE && sdkp->media_present) {
-		sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
+		sd_printk(KERN_NOTICE, sdkp, "1Synchronizing SCSI cache\n");
 		sd_sync_cache(sdkp, NULL);
+		sd_printk(KERN_NOTICE, sdkp, "1Synchronizing SCSI cache - done\n");
 	}
 
 	if (system_state != SYSTEM_RESTART && sdkp->device->manage_start_stop) {
-		sd_printk(KERN_NOTICE, sdkp, "Stopping disk\n");
-		sd_start_stop_device(sdkp, 0);
+		sd_printk(KERN_NOTICE, sdkp, "1Stopping disk - ok, not bypassing this!\n");
+		sd_start_stop_device(sdkp, 0);//was commented out, but not anymore now(since 3 may 2017), I am allowing it because echo 1 | sudo tee /sys/block/${blockdev}/device/delete >/dev/null  on the esata device(via ~/bin/esata_eject script) will call this! so it won't stop the disk unless I allow this! Also note: a second hdparm -Y /dev/sdb on the Samsung 1TB SSD will wake up the 'standby' device!(-C also wakes it up, which is status report: standby or active/idle) - so powering off kernel after this happens(by the kernel) will increase that POR_Recovery_Count (see smartctl) as if power was cut off to the drive
 	}
 }
 
@@ -3483,7 +3484,7 @@ static int sd_suspend_common(struct device *dev, bool ignore_stop_errors)
 		return 0;
 
 	if (sdkp->WCE && sdkp->media_present) {
-		sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
+		sd_printk(KERN_NOTICE, sdkp, "2Synchronizing SCSI cache\n");//never hit
 		ret = sd_sync_cache(sdkp, &sshdr);
 
 		if (ret) {
@@ -3505,7 +3506,7 @@ static int sd_suspend_common(struct device *dev, bool ignore_stop_errors)
 	}
 
 	if (sdkp->device->manage_start_stop) {
-		sd_printk(KERN_NOTICE, sdkp, "Stopping disk\n");
+		sd_printk(KERN_NOTICE, sdkp, "2Stopping disk\n");//never hit
 		/* an error is not worth aborting a system sleep */
 		ret = sd_start_stop_device(sdkp, 0);
 		if (ignore_stop_errors)
